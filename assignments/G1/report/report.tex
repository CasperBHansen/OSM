\documentclass[11pt]{article}

\usepackage{a4wide}             % save a few rain forests
\usepackage{amsmath,amssymb}    % we can do maths 'n shit
\usepackage{color}              % so purrty
\usepackage{float}              % put things exactly where I tell you!
\usepackage[utf8]{inputenc}     % i can has UTF-8
\usepackage{listings}           % pretty-colored code excerpts
\usepackage{multicol}           % such column.. very multi.. wow!

\definecolor{comment}{rgb}      {0.38, 0.62, 0.38}
\definecolor{keyword}{rgb}      {0.10, 0.10, 0.81}
\definecolor{identifier}{rgb}   {0.00, 0.00, 0.00}
\definecolor{string}{rgb}       {0.50, 0.50, 0.50}

\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\imp}{\rightarrow}

\lstset
{
    language=C++,
    % general settings
    numbers=left,
    frame=single,
    basicstyle=\footnotesize\ttfamily,
    tabsize=2,
    breaklines=true,
    % syntax highlighting
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    identifierstyle=\color{identifier},
    stringstyle=\color{string},
}

\title
{
    {\Large Group Assignment 1} \\
    Operating Systems and Multiprogramming
}

\author
{
    Anders Kiel Hovgaard \\
    University of Copenhagen \\
    Department of Computer Science \\
    {\tt hzs554@alumni.ku.dk}
    \and
    Casper B. Hansen \\
    University of Copenhagen \\
    Department of Computer Science \\
    {\tt fvx507@alumni.ku.dk}
    \and
    RÃºni Klein Hansen \\
    University of Copenhagen \\
    Department of Computer Science \\
    {\tt cdn768@alumni.ku.dk}
}

\date{last revision \today}

\begin{document}

\clearpage
\maketitle
\thispagestyle{empty}
\begin{multicols}{2}
    \begin{abstract}
    ...
    \end{abstract}
    \vfill\columnbreak
    \tableofcontents\vfill
\end{multicols}
\newpage

\section{Space-efficient doubly-linked list}
We will begin our discussion of our implementation of the space-efficient
doubly-linked list by making a few remarks. Note that because of the
implementations extensive use of the XOR-operation, and the fact that this
operation requires type-casting in all occurences of its use, we have declared
a preprocessor definition macro \code{XOR\_PTR} that relieves much repetitive
typing and makes the code a lot more readable--- an excerpt of the code
showing this macro has been provided below.

\begin{lstlisting}
#define XOR_PTR(a, b) ( (uintptr_t)a ^ (uintptr_t)b )
\end{lstlisting}

It should be noted that uses of preprocessor definitions are expanded by the
preprocessor before compilation of the code occurs.

\subsection{Insertion}
...

\subsection{Extraction}
\begin{lstlisting}
item * extract(dlist * this, bool atTail) {
    item * ret = NULL;
    if (!this->head) {
        return NULL;
    }
    else if (atTail) {
        // retrieve the item
        node * n = this->tail;
        ret = n->thing;
        // correct the head and tail
        node * prev = (node *) XOR_PTR(n->ptr, NULL);
        if (!prev) this->head = NULL;
        else prev->ptr = (node *) XOR_PTR(n, XOR_PTR(prev->ptr, NULL));
        this->tail = prev;
        // deallocate the node
        if (n) free(n);
        n = NULL;
    }
    else {
        // retrieve the item
        node * n = this->head;
        ret = n->thing;
        // correct the head and tail
        node * next = (node *)XOR_PTR(n->ptr, NULL);
        if (!next) this->tail = NULL;
        else next->ptr = (node *) XOR_PTR(n, XOR_PTR(next->ptr, NULL));
        this->head = next;
        // deallocate the node
        if (n) free(n);
        n = NULL;
    }
    return ret;
}
\end{lstlisting}
The extraction implementation is only dependant on the head and the tail. Thus
there is no chain of XORed pointers that have to be updated, only the immediate 
next node has to be updated and the dlist, ie. the struct pointing to the head
and tail. Thus the time complexity is fixed, ie. constant time.\\
Firsts checks if the list is empty, if so, return NULL. The next block is
triggered if the atTail is true, ie. an extraction of the tail of the list. The
next block is mostly the same, but extracts the head, so one explanation will
suffice:
The tail or head is assigned to a temporary variable n, and then ret is assigned
the value helt by tail or head. A new node next is assigned the updated XORed
pointer, if the next is empty, ie. the list is empty, the tail is set to NULL. 
And then the next element in the list is updated to point to the right node.
The node, if necessary, is deallocated.

\subsection{Reverse}
\begin{lstlisting}
void reverse(dlist * this) {
    node * tmp = this->head;
    this->head = this->tail;
    this->tail = tmp;
}
\end{lstlisting}

Since there is only ever gonna be three assignments, thus it will always take a
fixed amount of time, ie. $O(3)$.\\
What is happening is that the node head$_{this}$ is assigned to a temporary
variable tmp, tail$_{this}$ is then assigned to head$_{this}$ and at last the
tai$_{this}$ is assigned the value of tmp.

\subsection{Search}
...

\section{Buenos}
...

\subsection{Implementing read support}
...

\subsection{Implementing write support}
...

\end{document}

