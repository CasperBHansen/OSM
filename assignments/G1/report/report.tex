\documentclass[11pt]{article}

\usepackage{a4wide}             % save a few rain forests
\usepackage{amsmath,amssymb}    % we can do maths 'n shit
\usepackage{color}              % so purrty
\usepackage{float}              % put things exactly where I tell you!
\usepackage[utf8]{inputenc}     % i can has UTF-8
\usepackage{listings}           % pretty-colored code excerpts
\usepackage{multicol}           % such column.. very multi.. wow!

\definecolor{comment}{rgb}      {0.38, 0.62, 0.38}
\definecolor{keyword}{rgb}      {0.10, 0.10, 0.81}
\definecolor{identifier}{rgb}   {0.00, 0.00, 0.00}
\definecolor{string}{rgb}       {0.50, 0.50, 0.50}

\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\imp}{\rightarrow}

\lstset
{
    language=C++,
    % general settings
    numbers=left,
    frame=single,
    basicstyle=\footnotesize\ttfamily,
    tabsize=2,
    breaklines=true,
    % syntax highlighting
    commentstyle=\color{comment},
    keywordstyle=\color{keyword},
    identifierstyle=\color{identifier},
    stringstyle=\color{string},
}

\title
{
    {\Large Group Assignment 1} \\
    Operating Systems and Multiprogramming
}

\author
{
    Anders Kiel Hovgaard \\
    University of Copenhagen \\
    Department of Computer Science \\
    {\tt hzs554@alumni.ku.dk}
    \and
    Casper B. Hansen \\
    University of Copenhagen \\
    Department of Computer Science \\
    {\tt fvx507@alumni.ku.dk}
    \and
    RÃºni Klein Hansen \\
    University of Copenhagen \\
    Department of Computer Science \\
    {\tt cdn768@alumni.ku.dk}
}

\date{last revision \today}

\begin{document}

\clearpage
\maketitle
\thispagestyle{empty}
\begin{multicols}{2}
    \begin{abstract}
    ...
    \end{abstract}
    \vfill\columnbreak
    \tableofcontents\vfill
\end{multicols}
\newpage

\section{Space-efficient doubly-linked list}
We will begin our discussion of our implementation of the space-efficient
doubly-linked list by making a few remarks. Note that because of the
implementations extensive use of the XOR-operation, and the fact that this
operation requires type-casting in all occurences of its use, we have declared
a preprocessor definition macro \code{XOR\_PTR} that relieves much repetitive
typing and makes the code a lot more readable--- an excerpt of the code
showing this macro has been provided below.

\begin{lstlisting}
#define XOR_PTR(a, b) ( (uintptr_t)a ^ (uintptr_t)b )
\end{lstlisting}

It should be noted that uses of preprocessor definitions are expanded by the
preprocessor before compilation of the code occurs.\\
\\
The data structure to hold the list is given in the following code excerpt. One
struct \code{dlist} contains a pointer, of type \code{node} pointer, to the head
and one to the tail of the list. Another stuct of type \code{node} contains a
\code{void} pointer to the \code{item} in the node and a recursive \code{node}
pointer. This \code{node} pointer contains a pointer that is computed by
applying the XOR operator (\lstinline{^} as applied to pointer variables using
the aforementioned \lstinline{XOR_PTR} macro) to the node before and the node
after the node. Given a list of nodes \verb|A B C|, this allows the pointer to
node C to be calculated from the node pointer \code{ptr} in \verb|B| and the
address of \verb|A| as the pointer \code{A XOR ptr}.


\subsection{Insertion}
The insertion operation is implemented as the following function declaration, as
specified in the task description.
\begin{lstlisting}
void insert(dlist *this, item *thing, bool atTail);
\end{lstlisting}
The function takes as arguments, a pointer to a doubly-linked list, a pointer to
the item to be inserted in the list and a boolean value indicating whether to
insert at the head or at the tail of the list.


\subsection{Extraction}
...

\subsection{Reverse}
...

\subsection{Search}
...

\newpage
\section{Buenos}
For the implementation of read/write support in the Buenos operating system,
we chose to keep the extensions within the \file{proc/syscall.c}. We declared
functions in \file{proc/syscall.h} that have to do specifically with the
system call being handled. The following code excerpt are the declarations
found in \file{proc/syscall.h}.

\begin{lstlisting}
void handle_syscall_read(context_t * user_context);
void handle_syscall_write(context_t * user_context);
\end{lstlisting}

Preliminary preparations were done by adding cases for the two new system
calls, namely \code{SYSCALL\_READ} and \code{SYSCALL\_WRITE}, in the switch
statement. In these we simply called the newly declared functions, whose
bodies were left empty. Additionally, after running a simple test checking
whether or not these were actually called, we discovered that the program was
not being shutdown gracefully as we were getting a kernel panic of an
unhandled system call case, which after printing the case value we found to be
the \code{SYSCALL\_EXIT} case. We decided to add it to the switch statement
and handle it by simply replicating the body of \code{SYSCALL\_HALT}, although
we recognize that it may require additional implementation.

\subsection{Read/write commonalities}
Since the read and write functions have much in common, we will address these
common elements, like initialization, before moving on to their respective
implementations in which they differ.

Both functions require us to extract the arguments stored in CPU registers
\code{A1}, \code{A2} and \code{A3}, and since both functions use the arguments
for the same basic purpose, the types remain the same and hence initialization
of both functions also remains the same. An excerpt of the initialization code
of both \code{handle\_syscall\_read} and \code{handle\_syscall\_write} is
provided below.

\begin{lstlisting}
uint32_t fhandle = user_context->cpu_regs[MIPS_REGISTER_A1];
uint8_t * buffer = user_context->cpu_regs[MIPS_REGISTER_A2];
int length = user_context->cpu_regs[MIPS_REGISTER_A3];
\end{lstlisting}

The overall structure of both functions are more or less the same; check
whether or not we are reading or writing from a source or destination that is
supported (or required by the assignment). Otherwise we write an error code to
register \code{V0}.

\begin{lstlisting}
if (/* supported source or destination */) {
    // system call specific code
}
else {
    user_context->cpu_regs[MIPS_REGISTER_V0] = -1;
}
\end{lstlisting}

...

\subsection{Implementing read support}
...

\subsection{Implementing write support}
...

\end{document}

