%
% task2.tex
%
% Use kernel semaphores to implement userland semaphores.
%

\section{Userland semaphores}
Using the already implemented kernel semaphores, we will extend the
implementation to support userland semaphores.

\subsection{Preliminary}
We started out by adding the system call switch identifiers to
\file{proc/syscall.h}, such that we can recognize these. The identifier values
were specified by the assignment text.

\codefig{syscall-identifiers}{proc/syscall.h}{56}{59}
{Code excerpt showing the added system call identifiers.}

Having the identifiers in place we went on to declare the \code{usr\_sem\_t}
type \figref{code:semaphore.h}, which serves as a handle for userland
semaphores and added each of these to the cases of the system call handle
switch.

\codefig{syscall-switch}{proc/syscall.c}{181}{192}
{Code excerpt showing the added system call switch cases.}

Now that we are able to receive such system calls, we went on to implement the
userland library functions that will delegate the work on to these system
call handlers. 

Further, we added the prototype semaphore functions in \file{tests/lib.h} for
the userland library.

\codefig{userland-library-prototypes}{tests/lib.h}{70}{75}
{Code excerpt showing the userland library prototype functions.}

Lastly, for bridging the gap from the userland library in \file{tests/lib.h}
to the actual system call handlers in \file{proc/syscall.h}, we implemented
the userland library functions in \file{tests/lib.c}.

\codefig{userland-library-implementation}{tests/lib.c}{193}{213}
{Code excerpt showing the userland library implementation.}

In \file{proc/syscall.c} we then added \code{\#include "proc/semaphore.h"},
such that we can use the functionality to be implemented by it, and went on to
implement the functions called in the switch-statement
(\figref{code:syscall-switch}).

The \code{handle\_syscall\_sem\_open} function should extract the \code{name}
and \code{value} arguments found in registers \code{A1} and \code{A2}, casting
them to the appropriate types, \code{const char *} and \code{const int},
respectively, as done on lines 126--127. These are passed on to the userland
semaphore implementation (\code{semaphore\_userland\_open} in
\file{proc/semaphore.h}), the result of which is put back into register
\code{V0}, as done on line 128.

\codefig{handle_syscal_sem_open}{proc/syscall.c}{125}{129}
{Code excerpt showing the \code{handle\_syscall\_sem\_open}.}

For the remainder of the system call handlers, all take the same argument type
and have the same return type. Therefore, we will omit tedious repetition and
simply give an explanation of how they are all constructed.

All of the following functions take as their argument a userland semaphore
pointer (\code{usr\_sem\_t *}), so we extract this from register \code{A1},
casting it to the appropriate type on the first line of the function body.
Likewise, all of the following functions return an integer, so we call the
corresponding function (from \file{proc/semaphore.h}) with the extracted
argument, putting back the returned value into register \code{V0}.

\codefig{handle_syscall_sem_procure}{proc/syscall.c}{134}{137}
{Code excerpt showing the \code{handle\_syscall\_sem\_procure} implementation.}
\codefig{handle_syscall_sem_vacate}{proc/syscall.c}{142}{145}
{Code excerpt showing the \code{handle\_syscall\_sem\_vacate} implementation.}
\codefig{handle_syscall_sem_destroy}{proc/syscall.c}{117}{120}
{Code excerpt showing the \code{handle\_syscall\_sem\_destroy} implementation.}

Now, the system calls are being delegated on to the actual semaphore
implementation.

\subsection{Semaphore Implementation}
We must now declare the functions which are called by the system calls.

\codefig{semaphore.h}{proc/semaphore.h}{8}{21}
{Code excerpt showing some of \file{proc/semaphore.h}.}

On lines 8--9 we include the kernel semaphores, which we intend to wrap our
userland semaphore implementation around, and the kernel configuration
definitions. On lines 11--12 we define a maximum semaphore name length of
128 (made up number, no reasoning behind this), as well as the maximum number
of userland semaphores that should be available on the system --- this number,
however, is limited to half of the kernel semaphore capacity.

On line 16 we declare the \code{usr\_sem\_t} type, which serves as a handle
for the user to acquire and manipulate userland semaphores.

We will make sure that our userland semaphores are initialized, so on line
16 we declare a function for that. A call to this function was then added to
\file{init/main.c} after kernel semaphore initialization.

On lines 18--21 we declare the actual semaphore functions, called from
\file{proc/syscall.c}.

The actual semaphore data is masked by \code{usr\_sem\_t}, such that the user
cannot change the data stored within it. So we declared the structure
\code{sem\_t} which is obscurred by \code{usr\_sem\_t}. Since this type must
remain out the reach of the user, we declared it in \file{proc/semaphore.c},
making it available for the implementation but inaccessible to the user.

\codefig{sem_t}{proc/semaphore.h}{11}{15}
{Code excerpt showing the \code{sem\_t} type declaration.}
