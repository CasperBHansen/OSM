%
% task2.tex
%
% A simple shell and directory listing support.
%

\section{A Simple Shell}
Up until now the only form of input supported by the system, was to feed the
kernel with at start program and then let it run through everything
automatically. In this task we are given a small shell program and we are
supposed to implement some basic programs, such as ls, rm and cp.

\subsection{Command: exit}
There is not much code behind this command. A \code{syscall\_halt()} is issued
and thus halting the kernel.\\
Since the command requires no input, there is no check for the validness of the
input, since it is simply discarded.
\codefig{exitcommand}{tests/osh.c}{167}{171}{Code excerpt for the exit command.}

\subsection{Command: rm}
The input is checked, if argc is less than two, no input is given and the
operation is halted, since there was not given any input.\\
Then a while-loop is entered, the while loop is in effect while \code{i < argc},
where argc holds the amount of inputs given, ie. \code{rm file1 file2 file3},
means \textit{argc = 4}. The count variable i is set to 1, thus ignoring the
command name itself, then for every increment a file is deleted, if something
went wrong a message is given and the loop keeps on trucking until the exit
criteria is met. 
\codefig{rmcommand}{tests/osh.c}{190}{206}{Code excerpt for the rm command.}

\subsection{Command: cp}
The input is checked, if argc is different than 3 then the operation is halted
and a message on how to correctly use the command is given.\\
If \code{syscall\_open(argv[1])} is less than 3 an error has occured and the
operation is halted. Otherwise a handle of the source file is put into src. Then
it's time to get the size of the source file, this is done in the for-loop where
the criteria is \verb|syscall\_read(src, &dummy, 1)|, meaning that when the end
of file is reached a zero is returned and we get out of the loop again with the
file size in the is kept in the variable \code{size}. The reading position of
\code{src} is set to zero and while loop is initiated and the content is placed
into the buffer.\\
A check if the creation of the destination file is okay, if not an error has
occured and the operation is halted.
\codefig{cpcheck}{tests/osh.c}{140}{145}{Code excerpt from cp command, showing
the destination file check}


\subsection{Command: cmp}
The \code{argc}-variable is checked and if it differs from three, then the
operation is halted and a message is printed showing how to properly use the
command.\\
Then the files are opened, if unsuccessful the operation is halted and the
file(s) are closed. If successful then the for-loop is entered where all the
dirty work happens. If some of the following happen then the files are different
and the loop breaks:\\
\begin{itemize}
  \item \code{buf0 != buf1}\\
        In this case the files are identical right up to byte i, which is
        returned.
  \item \code{read\_ret0 < 0 || read\_ret1 < 0}\\
        An error occured when reading a file, -1 is returned.
  \item \code{read\_ret0 != read\_ret1}
        The file lengths differ ie. they are not alike. -1 is returned.
\end{itemize}
And at last, if everything turned out well thus far the files are indeed
identical and we have arrived at the last byte successfully. The loop is broken
and the files are closed.
\codefig{cmpcommand}{tests/osh.c}{208}{255}{Code excerpt for the cmp command.}

\subsection{Command: ls}

\subsection{Counting files}

